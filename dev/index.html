<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · NaNStatistics.jl</title><link rel="canonical" href="https://brenhinkeller.github.io/NaNStatistics.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">NaNStatistics.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="NaNStatistics"><a class="docs-heading-anchor" href="#NaNStatistics">NaNStatistics</a><a id="NaNStatistics-1"></a><a class="docs-heading-anchor-permalink" href="#NaNStatistics" title="Permalink"></a></h1><ul><li><a href="#NaNStatistics.histcounts-Tuple{Any, Any, AbstractRange, AbstractRange}"><code>NaNStatistics.histcounts</code></a></li><li><a href="#NaNStatistics.histcounts-Tuple{Any, AbstractRange}"><code>NaNStatistics.histcounts</code></a></li><li><a href="#NaNStatistics.histcounts!-Tuple{Array, AbstractArray, AbstractRange}"><code>NaNStatistics.histcounts!</code></a></li><li><a href="#NaNStatistics.histcounts!-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, AbstractRange, AbstractRange}"><code>NaNStatistics.histcounts!</code></a></li><li><a href="#NaNStatistics.inpctile-Tuple{Any, Any}"><code>NaNStatistics.inpctile</code></a></li><li><a href="#NaNStatistics.movmean-Tuple{AbstractVector{T} where T, Number}"><code>NaNStatistics.movmean</code></a></li><li><a href="#NaNStatistics.nanaad-Tuple{Any}"><code>NaNStatistics.nanaad</code></a></li><li><a href="#NaNStatistics.nanadd-Tuple{Any, Any}"><code>NaNStatistics.nanadd</code></a></li><li><a href="#NaNStatistics.nanadd!-Tuple{Array, AbstractArray}"><code>NaNStatistics.nanadd!</code></a></li><li><a href="#NaNStatistics.nanbinmean-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, AbstractRange, AbstractRange}"><code>NaNStatistics.nanbinmean</code></a></li><li><a href="#NaNStatistics.nanbinmean-Tuple{AbstractVector{T} where T, AbstractVecOrMat{T} where T, AbstractRange}"><code>NaNStatistics.nanbinmean</code></a></li><li><a href="#NaNStatistics.nanbinmean-Tuple{AbstractVector{T} where T, AbstractVecOrMat{T} where T, AbstractVector{T} where T, AbstractRange}"><code>NaNStatistics.nanbinmean</code></a></li><li><a href="#NaNStatistics.nanbinmean!-Tuple{AbstractVecOrMat{T} where T, AbstractVector{T} where T, AbstractVecOrMat{T} where T, AbstractRange}"><code>NaNStatistics.nanbinmean!</code></a></li><li><a href="#NaNStatistics.nanbinmean!-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, AbstractRange, AbstractRange}"><code>NaNStatistics.nanbinmean!</code></a></li><li><a href="#NaNStatistics.nanbinmedian-Tuple{AbstractVector{T} where T, AbstractVecOrMat{T} where T, AbstractRange}"><code>NaNStatistics.nanbinmedian</code></a></li><li><a href="#NaNStatistics.nanbinmedian!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, AbstractRange}"><code>NaNStatistics.nanbinmedian!</code></a></li><li><a href="#NaNStatistics.nancor-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}"><code>NaNStatistics.nancor</code></a></li><li><a href="#NaNStatistics.nancor-Tuple{AbstractMatrix{T} where T}"><code>NaNStatistics.nancor</code></a></li><li><a href="#NaNStatistics.nancov-Tuple{AbstractMatrix{T} where T}"><code>NaNStatistics.nancov</code></a></li><li><a href="#NaNStatistics.nancov-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}"><code>NaNStatistics.nancov</code></a></li><li><a href="#NaNStatistics.nanextrema-Tuple{Any}"><code>NaNStatistics.nanextrema</code></a></li><li><a href="#NaNStatistics.nanmad-Tuple{Any}"><code>NaNStatistics.nanmad</code></a></li><li><a href="#NaNStatistics.nanmask-Tuple{Any}"><code>NaNStatistics.nanmask</code></a></li><li><a href="#NaNStatistics.nanmask!-Tuple{Any, Any}"><code>NaNStatistics.nanmask!</code></a></li><li><a href="#NaNStatistics.nanmax-Tuple{Any, Any}"><code>NaNStatistics.nanmax</code></a></li><li><a href="#NaNStatistics.nanmaximum-Tuple{Any}"><code>NaNStatistics.nanmaximum</code></a></li><li><a href="#NaNStatistics.nanmean-Tuple{Any}"><code>NaNStatistics.nanmean</code></a></li><li><a href="#NaNStatistics.nanmean-Tuple{Any, Any}"><code>NaNStatistics.nanmean</code></a></li><li><a href="#NaNStatistics.nanmedian-Tuple{Any}"><code>NaNStatistics.nanmedian</code></a></li><li><a href="#NaNStatistics.nanmin-Tuple{Any, Any}"><code>NaNStatistics.nanmin</code></a></li><li><a href="#NaNStatistics.nanminimum-Tuple{Any}"><code>NaNStatistics.nanminimum</code></a></li><li><a href="#NaNStatistics.nanpctile-Tuple{Any, Any}"><code>NaNStatistics.nanpctile</code></a></li><li><a href="#NaNStatistics.nanrange-Tuple{Any}"><code>NaNStatistics.nanrange</code></a></li><li><a href="#NaNStatistics.nanstandardize-Tuple{AbstractArray}"><code>NaNStatistics.nanstandardize</code></a></li><li><a href="#NaNStatistics.nanstandardize!-Tuple{Array{var&quot;#s8&quot;, N} where {var&quot;#s8&quot;&lt;:AbstractFloat, N}}"><code>NaNStatistics.nanstandardize!</code></a></li><li><a href="#NaNStatistics.nanstd-Tuple{Any, Any}"><code>NaNStatistics.nanstd</code></a></li><li><a href="#NaNStatistics.nanstd-Tuple{Any}"><code>NaNStatistics.nanstd</code></a></li><li><a href="#NaNStatistics.nansum-Tuple{Any}"><code>NaNStatistics.nansum</code></a></li><li><a href="#NaNStatistics.nanvar-Tuple{Any}"><code>NaNStatistics.nanvar</code></a></li><li><a href="#NaNStatistics.zeronan!-Tuple{Array}"><code>NaNStatistics.zeronan!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.histcounts!-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, AbstractRange, AbstractRange}" href="#NaNStatistics.histcounts!-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, AbstractRange, AbstractRange}"><code>NaNStatistics.histcounts!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">histcounts!(N, x, y, xedges::AbstractRange, yedges::AbstractRange)</code></pre><p>Simple 2D histogram; as <code>histcounts</code>, but in-place, adding counts to the first <code>length(xedges)-1</code> columns and the first <code>length(yedges)-1</code> rows of <code>N</code> elements of Array <code>N</code>.</p><p>Note that counts will be added to <code>N</code>, not overwrite <code>N</code>, allowing you to produce cumulative histograms. However, this means you will have to initialize <code>N</code> with zeros before first use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/Histograms.jl#L119-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.histcounts!-Tuple{Array, AbstractArray, AbstractRange}" href="#NaNStatistics.histcounts!-Tuple{Array, AbstractArray, AbstractRange}"><code>NaNStatistics.histcounts!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">histcounts!(N, x, xedges::AbstractRange)</code></pre><p>Simple 1D histogram; as <code>histcounts</code>, but in-place, adding counts to the first <code>length(xedges)-1</code> elements of Array <code>N</code>.</p><p>Note that counts will be added to <code>N</code>, not overwrite <code>N</code>, allowing you to produce cumulative histograms. However, this means you will have to initialize <code>N</code> with zeros before first use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/Histograms.jl#L82-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.histcounts-Tuple{Any, AbstractRange}" href="#NaNStatistics.histcounts-Tuple{Any, AbstractRange}"><code>NaNStatistics.histcounts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">histcounts(x, xedges::AbstractRange; T=Int64)::Vector{T}</code></pre><p>A 1D histogram, ignoring NaNs: calculate the number of <code>x</code> values that fall into each of <code>length(xedges)-1</code> equally spaced bins along the <code>x</code> axis with bin edges specified by <code>xedges</code>.</p><p>By default, the counts are returned as <code>Int64</code>s, though this can be changed by specifying an output type with the optional keyword argument <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; b = 10 * rand(100000);

julia&gt; histcounts(b, 0:1:10)
10-element Vector{Int64}:
 10054
  9987
  9851
  9971
  9832
 10033
 10250
 10039
  9950
 10033</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/Histograms.jl#L2-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.histcounts-Tuple{Any, Any, AbstractRange, AbstractRange}" href="#NaNStatistics.histcounts-Tuple{Any, Any, AbstractRange, AbstractRange}"><code>NaNStatistics.histcounts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">histcounts(x, y, xedges::AbstractRange, yedges::AbstractRange; T=Int64)::Matrix{T}</code></pre><p>A 2D histogram, ignoring NaNs: calculate the number of <code>x, y</code> pairs that fall into each square of a 2D grid of equally-spaced square bins with edges specified by <code>xedges</code> and <code>yedges</code>.</p><p>The resulting matrix <code>N</code> of counts is oriented with the lowest x and y bins in <code>N[1,1]</code>, where the first (vertical / row) dimension of <code>N</code> corresponds to the y axis (with <code>size(N,1) == length(yedges)-1</code>) and the second (horizontal / column) dimension of <code>N</code> corresponds to the x axis (with <code>size(N,2) == length(xedges)-1</code>).</p><p>By default, the counts are returned as <code>Int64</code>s, though this can be changed by specifying an output type with the optional keyword argument <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; x = y = 0.5:9.5;

julia&gt; xedges = yedges = 0:10;

julia&gt; N = histcounts(x,y,xedges,yedges)
10×10 Matrix{Int64}:
 1  0  0  0  0  0  0  0  0  0
 0  1  0  0  0  0  0  0  0  0
 0  0  1  0  0  0  0  0  0  0
 0  0  0  1  0  0  0  0  0  0
 0  0  0  0  1  0  0  0  0  0
 0  0  0  0  0  1  0  0  0  0
 0  0  0  0  0  0  1  0  0  0
 0  0  0  0  0  0  0  1  0  0
 0  0  0  0  0  0  0  0  1  0
 0  0  0  0  0  0  0  0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/Histograms.jl#L39-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.inpctile-Tuple{Any, Any}" href="#NaNStatistics.inpctile-Tuple{Any, Any}"><code>NaNStatistics.inpctile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inpctile(A, p::Number; dims)</code></pre><p>Return a boolean array that identifies which values of the iterable collection <code>A</code> fall within the central <code>p</code>th percentile, optionally along a dimension specified by <code>dims</code>.</p><p>A valid percentile value must satisfy 0 &lt;= <code>p</code> &lt;= 100.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L125-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.movmean-Tuple{AbstractVector{T} where T, Number}" href="#NaNStatistics.movmean-Tuple{AbstractVector{T} where T, Number}"><code>NaNStatistics.movmean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">movmean(x::AbstractVecOrMat, n::Number)</code></pre><p>Simple moving average of <code>x</code> in 1 or 2 dimensions, spanning <code>n</code> bins (or n*n in 2D), returning an array of the same size as <code>x</code>.</p><p>For the resulting moving average to be symmetric, <code>n</code> must be an odd integer; if <code>n</code> is not an odd integer, the first odd integer greater than <code>n</code> will be used instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L547-L557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanaad-Tuple{Any}" href="#NaNStatistics.nanaad-Tuple{Any}"><code>NaNStatistics.nanaad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanaad(A; dims)</code></pre><p>Mean (average) absolute deviation from the mean, ignoring NaNs, of an indexable collection <code>A</code>, optionally along a dimension specified by <code>dims</code>. Note that for a Normal distribution, sigma = 1.253 * AAD.</p><p>Also supports the <code>dim</code> keyword, which behaves identically to <code>dims</code>, but also drops any singleton dimensions that have been reduced over (as is the convention in some other languages).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L497-L508">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanadd!-Tuple{Array, AbstractArray}" href="#NaNStatistics.nanadd!-Tuple{Array, AbstractArray}"><code>NaNStatistics.nanadd!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanadd!(A, B)</code></pre><p>Add the non-NaN elements of <code>B</code> to <code>A</code>, treating NaNs as zeros</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L162-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanadd-Tuple{Any, Any}" href="#NaNStatistics.nanadd-Tuple{Any, Any}"><code>NaNStatistics.nanadd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanadd(A, B)</code></pre><p>Add the non-NaN elements of A and B, treating NaNs as zeros</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L143-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanbinmean!-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, AbstractRange, AbstractRange}" href="#NaNStatistics.nanbinmean!-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, AbstractRange, AbstractRange}"><code>NaNStatistics.nanbinmean!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanbinmean!(MU, N, x, y, z, xedges::AbstractRange, yedges::AbstractRange)</code></pre><p>Ignoring NaNs, fill the matrix <code>MU</code> with the means and <code>N</code> with the counts of non-NAN <code>z</code> values that fall into a 2D grid of x and y bins defined by <code>xedges</code> and <code>yedges</code>. The independent variables <code>x</code> and <code>y</code>, as well as the dependent variable <code>z</code>, are all expected as 1D vectors (any subtype of AbstractVector).</p><p>The output matrices <code>MU</code> and <code>N</code> must be the same size, and must each have <code>length(yedges)-1</code> rows and <code>length(xedges)-1</code> columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/Binning.jl#L96-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanbinmean!-Tuple{AbstractVecOrMat{T} where T, AbstractVector{T} where T, AbstractVecOrMat{T} where T, AbstractRange}" href="#NaNStatistics.nanbinmean!-Tuple{AbstractVecOrMat{T} where T, AbstractVector{T} where T, AbstractVecOrMat{T} where T, AbstractRange}"><code>NaNStatistics.nanbinmean!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanbinmean!(MU, [N], x, y, xedges::AbstractRange)</code></pre><p>Ignoring NaNs, fill the array <code>MU</code> with the means (and optionally <code>N</code> with the counts) of non-NAN <code>y</code> values that fall into each of <code>length(xedges)-1</code> equally spaced bins along the <code>x</code> axis with bin edges specified by <code>xedges</code>.</p><p>The array of <code>x</code> data should given as a one-dimensional array (any subtype of AbstractVector) and <code>y</code> as either a 1-d or 2-d array (any subtype of AbstractVecOrMat).</p><p>The output arrays <code>MU</code> and <code>N</code> must be the same size, and must have the same number of columns as <code>y</code>; if <code>y</code> is a 2-d array (matrix), then each column of <code>y</code> will be treated as a separate variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/Binning.jl#L3-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanbinmean-Tuple{AbstractVector{T} where T, AbstractVecOrMat{T} where T, AbstractRange}" href="#NaNStatistics.nanbinmean-Tuple{AbstractVector{T} where T, AbstractVecOrMat{T} where T, AbstractRange}"><code>NaNStatistics.nanbinmean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanbinmean(x, y, xedges::AbstractRange)</code></pre><p>Ignoring NaNs, calculate the mean of <code>y</code> values that fall into each of <code>length(xedges)-1</code> equally spaced bins along the <code>x</code> axis with bin edges specified by <code>xedges</code>.</p><p>The array of <code>x</code> data should be given as a one-dimensional array (any subtype of AbstractVector) and <code>y</code> as either a 1-d or 2-d array (any subtype of AbstractVecOrMat). If <code>y</code> is a 2-d array, then each column of <code>y</code> will be treated as a separate variable.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; nanbinmean([1:100..., 1], [1:100..., NaN], 0:25:100)
4-element Vector{Float64}:
 13.0
 38.0
 63.0
 87.5

julia&gt; nanbinmean(1:100, reshape(1:300,100,3), 0:25:100)
4×3 Matrix{Float64}:
 13.0  113.0  213.0
 38.0  138.0  238.0
 63.0  163.0  263.0
 87.5  187.5  287.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/Binning.jl#L299-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanbinmean-Tuple{AbstractVector{T} where T, AbstractVecOrMat{T} where T, AbstractVector{T} where T, AbstractRange}" href="#NaNStatistics.nanbinmean-Tuple{AbstractVector{T} where T, AbstractVecOrMat{T} where T, AbstractVector{T} where T, AbstractRange}"><code>NaNStatistics.nanbinmean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanbinmean(x, y, xedges::AbstractRange)</code></pre><p>Ignoring NaNs, calculate the weighted mean of <code>y</code> values that fall into each of <code>length(xedges)-1</code> equally spaced bins along the <code>x</code> axis with bin edges specified by <code>xedges</code>.</p><p>The array of <code>x</code> data should given as a one-dimensional array (any subtype of AbstractVector) and <code>y</code> as either a 1-d or 2-d array (any subtype of AbstractVecOrMat). If <code>y</code> is a 2-d array, then each column of <code>y</code> will be treated as a separate variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/Binning.jl#L372-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanbinmean-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, AbstractRange, AbstractRange}" href="#NaNStatistics.nanbinmean-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, AbstractRange, AbstractRange}"><code>NaNStatistics.nanbinmean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanbinmean(x, y, z, xedges, yedges)</code></pre><p>Ignoring NaNs, calculate the mean of <code>z</code> values that fall into a 2D grid of x and y bins with bin edges defined by <code>xedges</code> and <code>yedges</code>. The independent variables <code>x</code> and <code>y</code>, as well as the dependent variable <code>z</code>, are all expected as 1D vectors (any subtype of AbstractVector).</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; x = y = z = 0.5:9.5;

julia&gt; xedges = yedges = 0:10;

julia&gt; nanbinmean(x,y,z,xedges,yedges)
10×10 Matrix{Float64}:
   0.5  NaN    NaN    NaN    NaN    NaN    NaN    NaN    NaN    NaN
 NaN      1.5  NaN    NaN    NaN    NaN    NaN    NaN    NaN    NaN
 NaN    NaN      2.5  NaN    NaN    NaN    NaN    NaN    NaN    NaN
 NaN    NaN    NaN      3.5  NaN    NaN    NaN    NaN    NaN    NaN
 NaN    NaN    NaN    NaN      4.5  NaN    NaN    NaN    NaN    NaN
 NaN    NaN    NaN    NaN    NaN      5.5  NaN    NaN    NaN    NaN
 NaN    NaN    NaN    NaN    NaN    NaN      6.5  NaN    NaN    NaN
 NaN    NaN    NaN    NaN    NaN    NaN    NaN      7.5  NaN    NaN
 NaN    NaN    NaN    NaN    NaN    NaN    NaN    NaN      8.5  NaN
 NaN    NaN    NaN    NaN    NaN    NaN    NaN    NaN    NaN      9.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/Binning.jl#L337-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanbinmedian!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, AbstractRange}" href="#NaNStatistics.nanbinmedian!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, AbstractRange}"><code>NaNStatistics.nanbinmedian!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanbinmedian!(M, [N], x, y, xedges::AbstractRange)</code></pre><p>Fill the array <code>M</code> with the medians (and optionally <code>N</code> with the counts) of non-NaN <code>y</code> values that fall into each of <code>length(xedges)-1</code> equally spaced bins along the <code>x</code> axis with bin edges specified by <code>xedges</code>.</p><p>If <code>y</code> is a 2-d array (matrix), each column will be treated as a separate variable</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/Binning.jl#L236-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanbinmedian-Tuple{AbstractVector{T} where T, AbstractVecOrMat{T} where T, AbstractRange}" href="#NaNStatistics.nanbinmedian-Tuple{AbstractVector{T} where T, AbstractVecOrMat{T} where T, AbstractRange}"><code>NaNStatistics.nanbinmedian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanbinmedian(x, y, xedges::AbstractRange)</code></pre><p>Calculate the median, ignoring NaNs, of y values that fall into each of <code>length(xedges)-1</code> equally spaced bins along the <code>x</code> axis with bin edges specified by <code>xedges</code>.</p><p>If <code>y</code> is a 2-d array (matrix), each column will be treated as a separate variable</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; nanbinmedian([1:100..., 1], [1:100..., NaN], 0:25:100)
4-element Vector{Float64}:
 12.5
 37.0
 62.0
 87.0

julia&gt; nanbinmedian(1:100, reshape(1:300,100,3), 0:25:100)
4×3 Matrix{Float64}:
 12.5  112.5  212.5
 37.0  137.0  237.0
 62.0  162.0  262.0
 87.0  187.0  287.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/Binning.jl#L393-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nancor-Tuple{AbstractMatrix{T} where T}" href="#NaNStatistics.nancor-Tuple{AbstractMatrix{T} where T}"><code>NaNStatistics.nancor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nancor(X::AbstractMatrix; dims::Int=1)</code></pre><p>Compute the (Pearson&#39;s product-moment) correlation matrix of the matrix <code>X</code>, along dimension <code>dims</code>. As <code>Statistics.cor</code>, but ignoring <code>NaN</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/nancov.jl#L115-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nancor-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}" href="#NaNStatistics.nancor-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}"><code>NaNStatistics.nancor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nancor(x::AbstractVector, y::AbstractVector)</code></pre><p>Compute the (Pearson&#39;s product-moment) correlation between the vectors <code>x</code> and <code>y</code>. As <code>Statistics.cor</code>, but ignoring <code>NaN</code>s.</p><p>Equivalent to <code>nancov(x,y) / (nanstd(x) * nanstd(y))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/nancov.jl#L89-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nancov-Tuple{AbstractMatrix{T} where T}" href="#NaNStatistics.nancov-Tuple{AbstractMatrix{T} where T}"><code>NaNStatistics.nancov</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nancov(X::AbstractMatrix; dims::Int=1, corrected::Bool=true)</code></pre><p>Compute the covariance matrix of the matrix <code>X</code>, along dimension <code>dims</code>. As <code>Statistics.cov</code>, but ignoring <code>NaN</code>s.</p><p>If <code>corrected</code> is <code>true</code> as is the default, <em>Bessel&#39;s correction</em> will be applied, such that the sum is scaled by <code>n-1</code> rather than <code>n</code>, where <code>n = length(x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/nancov.jl#L40-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nancov-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}" href="#NaNStatistics.nancov-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}"><code>NaNStatistics.nancov</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nancov(x::AbstractVector, y::AbstractVector; corrected::Bool=true)</code></pre><p>Compute the covariance between the vectors <code>x</code> and <code>y</code>. As <code>Statistics.cov</code>, but ignoring <code>NaN</code>s.</p><p>If <code>corrected</code> is <code>true</code> as is the default, <em>Bessel&#39;s correction</em> will be applied, such that the sum is scaled by <code>n-1</code> rather than <code>n</code>, where <code>n = length(x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/nancov.jl#L18-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanextrema-Tuple{Any}" href="#NaNStatistics.nanextrema-Tuple{Any}"><code>NaNStatistics.nanextrema</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanextrema(A; dims)</code></pre><p>Find the extrema (maximum &amp; minimum) of an indexable collection <code>A</code>, ignoring NaNs, optionally along a dimension specified by <code>dims</code>.</p><p>Also supports the <code>dim</code> keyword, which behaves identically to <code>dims</code>, but also drops any singleton dimensions that have been reduced over (as is the convention in some other languages).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L263-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanmad-Tuple{Any}" href="#NaNStatistics.nanmad-Tuple{Any}"><code>NaNStatistics.nanmad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmad(A; dims)</code></pre><p>Median absolute deviation from the median, ignoring NaNs, of an indexable collection <code>A</code>, optionally along a dimension specified by <code>dims</code>. Note that for a Normal distribution, sigma = 1.4826 * MAD.</p><p>Also supports the <code>dim</code> keyword, which behaves identically to <code>dims</code>, but also drops any singleton dimensions that have been reduced over (as is the convention in some other languages).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L479-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanmask!-Tuple{Any, Any}" href="#NaNStatistics.nanmask!-Tuple{Any, Any}"><code>NaNStatistics.nanmask!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmask!(mask, A)</code></pre><p>Fill a Boolean mask of dimensions <code>size(A)</code> that is false wherever <code>A</code> is <code>NaN</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanmask-Tuple{Any}" href="#NaNStatistics.nanmask-Tuple{Any}"><code>NaNStatistics.nanmask</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmask(A)</code></pre><p>Create a Boolean mask of dimensions <code>size(A)</code> that is false wherever <code>A</code> is <code>NaN</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanmax-Tuple{Any, Any}" href="#NaNStatistics.nanmax-Tuple{Any, Any}"><code>NaNStatistics.nanmax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmax(a,b)</code></pre><p>As <code>max(a,b)</code>, but if either argument is <code>NaN</code>, return the other one</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L56-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanmaximum-Tuple{Any}" href="#NaNStatistics.nanmaximum-Tuple{Any}"><code>NaNStatistics.nanmaximum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmaximum(A; dims)</code></pre><p>Find the largest non-NaN value of an indexable collection <code>A</code>, optionally along a dimension specified by <code>dims</code>.</p><p>Also supports the <code>dim</code> keyword, which behaves identically to <code>dims</code>, but also drops any singleton dimensions that have been reduced over (as is the convention in some other languages).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L243-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanmean-Tuple{Any, Any}" href="#NaNStatistics.nanmean-Tuple{Any, Any}"><code>NaNStatistics.nanmean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmean(A, W; dims)</code></pre><p>Ignoring NaNs, calculate the weighted mean of an indexable collection <code>A</code>, optionally along dimensions specified by <code>dims</code>.</p><p>Also supports the <code>dim</code> keyword, which behaves identically to <code>dims</code>, but also drops any singleton dimensions that have been reduced over (as is the convention in some other languages).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L296-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanmean-Tuple{Any}" href="#NaNStatistics.nanmean-Tuple{Any}"><code>NaNStatistics.nanmean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmean(A; dims)</code></pre><p>Compute the mean of all non-<code>NaN</code> elements in <code>A</code>, optionally over dimensions specified by <code>dims</code>. As <code>Statistics.mean</code>, but ignoring <code>NaN</code>s.</p><p>As an alternative to <code>dims</code>, <code>nanmean</code> also supports the <code>dim</code> keyword, which behaves identically to <code>dims</code>, but also drops any singleton dimensions that have been reduced over (as is the convention in some other languages).</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; using NaNStatistics

julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; nanmean(A, dims=1)
1×2 Matrix{Float64}:
 2.0  3.0

julia&gt; nanmean(A, dims=2)
2×1 Matrix{Float64}:
 1.5
 3.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/nanmean.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanmedian-Tuple{Any}" href="#NaNStatistics.nanmedian-Tuple{Any}"><code>NaNStatistics.nanmedian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmedian(A; dims)</code></pre><p>Calculate the median, ignoring NaNs, of an indexable collection <code>A</code>, optionally along a dimension specified by <code>dims</code>.</p><p>Also supports the <code>dim</code> keyword, which behaves identically to <code>dims</code>, but also drops any singleton dimensions that have been reduced over (as is the convention in some other languages).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L436-L446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanmin-Tuple{Any, Any}" href="#NaNStatistics.nanmin-Tuple{Any, Any}"><code>NaNStatistics.nanmin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmin(a,b)</code></pre><p>As <code>min(a,b)</code>, but if either argument is <code>NaN</code>, return the other one</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanminimum-Tuple{Any}" href="#NaNStatistics.nanminimum-Tuple{Any}"><code>NaNStatistics.nanminimum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanminimum(A; dims)</code></pre><p>As <code>minimum</code> but ignoring <code>NaN</code>s: Find the smallest non-<code>NaN</code> value of an indexable collection <code>A</code>, optionally along a dimension specified by <code>dims</code>.</p><p>Also supports the <code>dim</code> keyword, which behaves identically to <code>dims</code>, but also drops any singleton dimensions that have been reduced over (as is the convention in some other languages).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L223-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanpctile-Tuple{Any, Any}" href="#NaNStatistics.nanpctile-Tuple{Any, Any}"><code>NaNStatistics.nanpctile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanpctile(A, p; dims</code></pre><p>Find the <code>p</code>th percentile of an indexable collection <code>A</code>, ignoring NaNs, optionally along a dimension specified by <code>dims</code>.</p><p>A valid percentile value must satisfy 0 &lt;= <code>p</code> &lt;= 100.</p><p>Also supports the <code>dim</code> keyword, which behaves identically to <code>dims</code>, but also drops any singleton dimensions that have been reduced over (as is the convention in some other languages).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L80-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanrange-Tuple{Any}" href="#NaNStatistics.nanrange-Tuple{Any}"><code>NaNStatistics.nanrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanrange(A; dims)</code></pre><p>Calculate the range (maximum - minimum) of an indexable collection <code>A</code>, ignoring NaNs, optionally along a dimension specified by <code>dims</code>.</p><p>Also supports the <code>dim</code> keyword, which behaves identically to <code>dims</code>, but also drops any singleton dimensions that have been reduced over (as is the convention in some other languages).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L281-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanstandardize!-Tuple{Array{var&quot;#s8&quot;, N} where {var&quot;#s8&quot;&lt;:AbstractFloat, N}}" href="#NaNStatistics.nanstandardize!-Tuple{Array{var&quot;#s8&quot;, N} where {var&quot;#s8&quot;&lt;:AbstractFloat, N}}"><code>NaNStatistics.nanstandardize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanstandardize!(A::Array{&lt;:AbstractFloat}; dims)</code></pre><p>Rescale <code>A</code> to unit variance and zero mean i.e. <code>A .= (A .- nanmean(A)) ./ nanstd(A)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L517-L523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanstandardize-Tuple{AbstractArray}" href="#NaNStatistics.nanstandardize-Tuple{AbstractArray}"><code>NaNStatistics.nanstandardize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanstandardize(A; dims)</code></pre><p>Rescale a copy of <code>A</code> to unit variance and zero mean i.e. <code>(A .- nanmean(A)) ./ nanstd(A)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L534-L540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanstd-Tuple{Any, Any}" href="#NaNStatistics.nanstd-Tuple{Any, Any}"><code>NaNStatistics.nanstd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanstd(A, W; dims)</code></pre><p>Calculate the weighted standard deviation, ignoring NaNs, of an indexable collection <code>A</code>, optionally along a dimension specified by <code>dims</code>.</p><p>Also supports the <code>dim</code> keyword, which behaves identically to <code>dims</code>, but also drops any singleton dimensions that have been reduced over (as is the convention in some other languages).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L357-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanstd-Tuple{Any}" href="#NaNStatistics.nanstd-Tuple{Any}"><code>NaNStatistics.nanstd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanstd(A; dims=:, mean=nothing, corrected=true)</code></pre><p>Compute the variance of all non-<code>NaN</code> elements in <code>A</code>, optionally over dimensions specified by <code>dims</code>. As <code>Statistics.var</code>, but ignoring <code>NaN</code>s.</p><p>A precomputed <code>mean</code> may optionally be provided, which results in a somewhat faster calculation. If <code>corrected</code> is <code>true</code>, then <em>Bessel&#39;s correction</em> is applied, such that the sum is divided by <code>n-1</code> rather than <code>n</code>.</p><p>As an alternative to <code>dims</code>, <code>nanstd</code> also supports the <code>dim</code> keyword, which behaves identically to <code>dims</code>, but also drops any singleton dimensions that have been reduced over (as is the convention in some other languages).</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; using NaNStatistics

julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; nanstd(A, dims=1)
1×2 Matrix{Float64}:
 1.41421  1.41421

julia&gt; nanstd(A, dims=2)
2×1 Matrix{Float64}:
 0.7071067811865476
 0.7071067811865476</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/nanstd.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nansum-Tuple{Any}" href="#NaNStatistics.nansum-Tuple{Any}"><code>NaNStatistics.nansum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nansum(A; dims)</code></pre><p>Calculate the sum of an indexable collection <code>A</code>, ignoring NaNs, optionally along dimensions specified by <code>dims</code>.</p><p>Also supports the <code>dim</code> keyword, which behaves identically to <code>dims</code>, but also drops any singleton dimensions that have been reduced over (as is the convention in some other languages).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L181-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.nanvar-Tuple{Any}" href="#NaNStatistics.nanvar-Tuple{Any}"><code>NaNStatistics.nanvar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanvar(A; dims=:, mean=nothing, corrected=true)</code></pre><p>Compute the variance of all non-<code>NaN</code> elements in <code>A</code>, optionally over dimensions specified by <code>dims</code>. As <code>Statistics.var</code>, but ignoring <code>NaN</code>s.</p><p>A precomputed <code>mean</code> may optionally be provided, which results in a somewhat faster calculation. If <code>corrected</code> is <code>true</code>, then <em>Bessel&#39;s correction</em> is applied, such that the sum is divided by <code>n-1</code> rather than <code>n</code>.</p><p>As an alternative to <code>dims</code>, <code>nanvar</code> also supports the <code>dim</code> keyword, which behaves identically to <code>dims</code>, but also drops any singleton dimensions that have been reduced over (as is the convention in some other languages).</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; using NaNStatistics

julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; nanvar(A, dims=1)
1×2 Matrix{Float64}:
 2.0  2.0

julia&gt; nanvar(A, dims=2)
2×1 Matrix{Float64}:
 0.5
 0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/nanvar.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaNStatistics.zeronan!-Tuple{Array}" href="#NaNStatistics.zeronan!-Tuple{Array}"><code>NaNStatistics.zeronan!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zeronan!(A)</code></pre><p>Replace all <code>NaN</code>s in A with zeros of the same type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/NaNStatistics.jl/blob/0d556e490e8be1ae865a1a0963bd7db5dc2a0b38/src/ArrayStats/ArrayStats.jl#L38-L43">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 14 June 2021 00:32">Monday 14 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
